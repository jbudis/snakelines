import pickle
import pandas as pd
from Bio import SeqIO

blast_binaries = {
    ('nucleotide', 'nucleotide'): 'blastn',
    ('nucleotide', 'protein'):    'blastx',
    ('protein',    'nucleotide'): 'tblastn',
    ('protein',    'protein'):    'blastp'
}

blast_db_suffix = {
    'nucleotide': 'nsq',
    'protein':    'psq'
}

rule blast_tsv:
    input:
        '{indir}/{name}.fa'
    output:
        '{indir}/blast/{reference}/{name}.blast.tsv'
    threads:
        int(config['threads'])
    params:
        nohead = '{indir}/blast/{reference}/{name}.blast.tsv.tmp',
        header = '{indir}/blast/{reference}/{name}.blast.tsv.tmp.header',
        max_target_seqs = lambda wc: config['blast']['reference'][wc.reference]['max_target_seqs'],
        blast_binary    = lambda wc: blast_binaries[(config['blast']['reference'][wc.reference]['query_type'],
                                                     config['blast']['reference'][wc.reference]['target_type'])],
        blast_database  = 'reference/{reference}/blast_index/{reference}'
    shell:
        '''
        set +e pipefail
        HEADER="qseqid \
                sacc staxid stitle \
                pident evalue length mismatch \
                gapopen qstart qend \
                sstart send"

        # TODO really ugly way to get header to the blast table, find better way
        HEADER=`echo "$HEADER" | sed -E -e  's/[[:blank:]]+/\t/g'`
        echo $HEADER  > {params.header}
        sed -i 's/\s/\t/g' {params.header}

        {params.blast_binary} \
            -db {params.blast_database} \
            -query {input} \
            -out {params.nohead} \
            -outfmt "6 `echo $HEADER`" \
            -num_threads {threads} \
            -max_target_seqs {params.max_target_seqs}

        cat {params.header} {params.nohead} > {output}
        rm {params.header} {params.nohead}
        '''

rule blast_annotate_with_taxonomy:
    input:
        blast = '{indir}/blast/{name}.blast.tsv',
        taxes = '/data/genome/metagenome/blast/nt/17-01-17/taxonomy/code_taxonomy.pickle'
    output:
        blast = '{indir}/blast/{name}.blast.tax.tsv'
    run:
        taxes = pickle.load(open(input.taxes, 'rb'))

        def get_tax(taxid):
            if not taxid or taxid == 'N/A':
                return ''
            taxid = int(taxid)
            return ';'.join(taxes.get(taxid, ''))

        with open(input.blast) as in_blast, open(output.blast, 'w') as out_blast:
            for i, line in enumerate(in_blast):
                items = line.strip().split("\t")
                if i == 0:
                    tax_col = items.index('staxid')
                    to_insert = 'taxonomy'
                else:
                    tax = get_tax(items[tax_col])
                    to_insert = tax

                items = items[:tax_col] + [to_insert] + items[tax_col:]
                out_blast.write('\t'.join(items))
                out_blast.write('\n')

rule blast_filter_by_kingdom:
    input:
        blast = '{indir}/blast/{name}.blast.tax.tsv'
    output:
        blast = '{indir}/blast/{name}.blast.tax.{kingdom, [a-z]+}.tsv'
    run:
        with open(input.blast) as in_blast, open(output.blast, 'w') as out_blast:
            for i, line in enumerate(in_blast):
                items = line.strip().split("\t")
                if i == 0:
                    tax_col = items.index('taxonomy')
                else:
                    tax = items[tax_col].lower()
                    if not tax.startswith(wildcards.kingdom):
                        continue

                out_blast.write(line)

rule blast_extract_contigs_by_kingdom:
    input:
        blast = '{indir}/blast/{name}.blast.tax.{kingdom}.tsv',
        fasta = '{indir}/{name}.fa'
    output:
        fasta = '{indir}/{name}.blast.tax.{kingdom}.fa'
    run:
        # Store all fasta contigs into memory
        contigs = {contig.id: contig for contig in SeqIO.parse(input.fasta, 'fasta')}

        already_stored = set()
        with open(input.blast) as in_blast, open(output.fasta, 'w') as out_fasta:
            for i, line in enumerate(in_blast):
                items = line.strip().split("\t")
                if i == 0:
                    contig_id_col = items.index('qseqid')
                else:
                    contig_id = items[contig_id_col]
                    if contig_id in already_stored:
                        continue

                    SeqIO.write(contigs[contig_id], out_fasta, 'fasta')
                    already_stored.add(contig_id)