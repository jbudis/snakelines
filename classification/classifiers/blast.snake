import pickle
import pandas as pd
from glob import glob
from Bio import SeqIO

blast_binaries = {
    ('nucleotide', 'nucleotide'): 'blastn',
    ('nucleotide', 'protein'):    'blastx',
    ('protein',    'nucleotide'): 'tblastn',
    ('protein',    'protein'):    'blastp'
}

blast_db_suffices = {
    'nucleotide': 'nsq',
    'protein':    'psq'
}

def find_blast_db(wildcards):
    target_type = config['blast']['reference'][wildcards.reference]['target_type']

    db_suffix = blast_db_suffices[target_type]
    indices = glob('reference/{reference}/blast_index/{reference}.*{db_suffix}' \
                        .format(reference=wildcards.reference, db_suffix=db_suffix))
    if indices:
        return indices

    print('reference/{reference}/blast_index/{reference}.{db_suffix}' \
                        .format(reference=wildcards.reference, db_suffix=db_suffix))

    return 'reference/{reference}/blast_index/{reference}.{db_suffix}' \
                        .format(reference=wildcards.reference, db_suffix=db_suffix)

rule blast_tsv:
    input:
        fasta = '{indir}/{name}.fa',
        db = find_blast_db
    output:
        '{indir}/blast/{reference}/{name}.blast.tsv'
    threads:
        int(config['threads'])
    params:
        nohead = '{indir}/blast/{reference}/{name}.blast.tsv.tmp',
        header = '{indir}/blast/{reference}/{name}.blast.tsv.tmp.header',
        max_target_seqs = lambda wc: config['blast']['reference'][wc.reference]['max_target_seqs'],
        blast_binary    = lambda wc: blast_binaries[(config['blast']['reference'][wc.reference]['query_type'],
                                                     config['blast']['reference'][wc.reference]['target_type'])],
        blast_database  = 'reference/{reference}/blast_index/{reference}'
    shell:
        '''
        set +e pipefail
        HEADER="qseqid \
                sacc staxid stitle \
                pident evalue length mismatch \
                gapopen qstart qend \
                sstart send \
                qlen slen"

        # TODO really ugly way to get header to the blast table, find better way
        HEADER=`echo "$HEADER" | sed -E -e  's/[[:blank:]]+/\t/g'`
        echo $HEADER  > {params.header}
        sed -i 's/\s/\t/g' {params.header}

        {params.blast_binary} \
            -db {params.blast_database} \
            -query {input.fasta} \
            -out {params.nohead} \
            -outfmt "6 `echo $HEADER`" \
            -num_threads {threads} \
            -max_target_seqs {params.max_target_seqs}

        cat {params.header} {params.nohead} > {output}
        rm {params.header} {params.nohead}
        '''

rule blast_annotate_with_taxonomy:
    input:
        blast = '{indir}/blast/{name}.blast.tsv',
        taxes = '/data/genome/metagenome/blast/nt/17-01-17/taxonomy/code_taxonomy.pickle'
    output:
        blast = '{indir}/blast/{name}.blast.tax.tsv'
    run:
        taxes = pickle.load(open(input.taxes, 'rb'))

        def get_tax(taxid):
            if not taxid or taxid == 'N/A':
                return ''
            taxid = int(taxid)
            return ';'.join(taxes.get(taxid, ''))

        with open(input.blast) as in_blast, open(output.blast, 'w') as out_blast:
            for i, line in enumerate(in_blast):
                items = line.strip().split("\t")
                if i == 0:
                    tax_col = items.index('staxid')
                    to_insert = 'taxonomy'
                else:
                    tax = get_tax(items[tax_col])
                    to_insert = tax

                items = items[:tax_col] + [to_insert] + items[tax_col:]
                out_blast.write('\t'.join(items))
                out_blast.write('\n')

rule blast_filter_by_kingdom:
    input:
        blast = '{indir}/blast/{name}.blast.tax.tsv'
    output:
        blast = '{indir}/blast/{name}.blast.tax.{kingdom, [a-z]+}.tsv'
    run:
        with open(input.blast) as in_blast, open(output.blast, 'w') as out_blast:
            for i, line in enumerate(in_blast):
                items = line.strip().split("\t")
                if i == 0:
                    tax_col = items.index('taxonomy')
                else:
                    tax = items[tax_col].lower()
                    if not tax.startswith(wildcards.kingdom):
                        continue

                out_blast.write(line)

rule blast_extract_contigs_by_kingdom:
    input:
        blast = '{indir}/blast/{name}.blast.tax.{kingdom}.tsv',
        fasta = '{indir}/{name}.fa'
    output:
        fasta = '{indir}/{name}.blast.tax.{kingdom}.fa'
    run:
        # Store all fasta contigs into memory
        contigs = {contig.id: contig for contig in SeqIO.parse(input.fasta, 'fasta')}

        already_stored = set()
        with open(input.blast) as in_blast, open(output.fasta, 'w') as out_fasta:
            for i, line in enumerate(in_blast):
                items = line.strip().split("\t")
                if i == 0:
                    contig_id_col = items.index('qseqid')
                else:
                    contig_id = items[contig_id_col]
                    if contig_id in already_stored:
                        continue

                    SeqIO.write(contigs[contig_id], out_fasta, 'fasta')
                    already_stored.add(contig_id)



rule blast_assign_taxonomy_assemblers:
    input:
        fa = '{assembler}/{reference}/{indir}/{sample}.fa',
        blast = '{assembler}/{reference}/{indir}/blast/{reference}/{sample}.blast.tsv',
        tax = 'reference/{reference}/{reference}.tax'
    output:
        tax = '{assembler, matam}/{reference}/{indir, [a-z]+}/{sample}.tax'
    run:
        # Load ids and taxonomies for reference sequences
        taxes = pd.read_csv(input.tax, header=None, index_col=0, sep='\t')[1]

        # Load homologues found by blast
        blast = pd.read_csv(input.blast, index_col=None, sep='\t') \
                  .drop_duplicates(subset=['qseqid'], keep='first') \
                  .set_index('qseqid')

        # Assign taxonomies for best hit homologues to sequences from fasta
        with open(output.tax, 'w') as outtax:
            for query in SeqIO.parse(input.fa, 'fasta'):
                tax = 'Unknown'
                if query.id in blast.index:
                    homologue = blast.loc[query.id]['sacc']
                    tax = taxes[homologue]

                outtax.write('{qid}\t{taxonomy}\n'.format(qid=query.id, taxonomy=tax))