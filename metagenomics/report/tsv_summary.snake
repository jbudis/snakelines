import os

import pandas as pd
import csv
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

SUPPORTED_IMAGE_FORMATS = ['png', 'svg', 'pdf', 'tif', 'tiff', 'eps']

def individual_krn_files(wildcards):
    gene_file_pattern = re.compile(config['gene_pattern'][wildcards.gene])
    gene_sids = list(filter(gene_file_pattern.match, pipeline.sample))
    return expand('%s/%s/report/krona/individual/{sample}.krn' % (wildcards.analysis_dir, wildcards.gene),
                  sample=gene_sids)

tax_ranks = ['kingdom', 'phylum', 'class', 'order', 'family',
             'genus', 'species', 'subspecies', 'subsubspecies', 'variety', 'form']

rule summarize_single:
    input:
        individual_krn_files
    output:
        summary_xlsx = '{analysis_dir}/{gene}/report/tsv/summary.xlsx',
        summary_tsv  = '{analysis_dir}/{gene}/report/tsv/summary.tsv',
        subtax_xlsx  = '{analysis_dir}/{gene}/report/tsv/subtaxes.xlsx',
        subtax_tsv   = '{analysis_dir}/{gene}/report/tsv/subtaxes.tsv',
        normed_xlsx  = '{analysis_dir}/{gene}/report/tsv/subtaxes.norm.xlsx',
        normed_tsv   = '{analysis_dir}/{gene}/report/tsv/subtaxes.norm.tsv'
    run:
        # Load stored taxonomic abundances from Emirge analysis step

        global tax_ranks

        def load_abundances(sample_file):
            taxes = {}
            with open(sample_file) as sf:
                for line in sf:
                    tax, count = line[line.find('\t')+1:].strip(), float(line.split('\t')[0])
                    taxes[tax] = taxes.get(tax, 0) + count
            return taxes

        samples = [af.split('/')[-1][:-4] for af in input]
        abundances = list(map(load_abundances, input))

        # Aggregate abundances into summary table

        dupl_taxonomies = [sample_abundance.keys() for sample_abundance in abundances]
        taxonomies = set()
        for sample_taxes in dupl_taxonomies:
            taxonomies = taxonomies | set(sample_taxes)
        taxonomies = sorted(list(taxonomies))

        # Convert into vectors

        max_tax = -1
        for tax in taxonomies:
            max_tax = max(max_tax, tax.count('\t') + 1)
        tax_ranks = tax_ranks[:max_tax]


        def split_tax(taxonomy):
            taxes = taxonomy.split('\t')
            taxes.extend([np.nan]*(len(tax_ranks) - len(taxes)))
            return taxes

        split_taxonomies = [split_tax(tax) for tax in taxonomies]

        # Store into summary table

        tax_table = pd.DataFrame(split_taxonomies, columns=tax_ranks)
        tax_table.dropna(axis=1, how='all', inplace=True)
        tax_ranks = [tr for tr in tax_ranks if tr in tax_table.columns]

        for sample, sample_abundance in zip(samples, abundances):
            tax_table[sample] = [sample_abundance.get(tax, 0) for tax in taxonomies]
            tax_table[sample] = tax_table[sample].apply(pd.to_numeric)

        tax_table.sort_values(tax_ranks, ascending=True, na_position='first', inplace=True)

        tax_table.to_excel(output.summary_xlsx, index=False)
        tax_table.to_csv(output.summary_tsv, sep='\t', index=False)

        # Generate rows for aggregated taxes, for example all Bacteria, all Actinobacteria ...

        next_index = max(tax_table.index + 1)
        sub_tables = []

        for i, tax_rank in enumerate(tax_ranks[:-1]):
            sub_ranks = tax_ranks[:i+1]
            sub_counts = tax_table.groupby(sub_ranks).sum()
            sub_indices = range(next_index, next_index + len(sub_counts))
            next_index = sub_indices[-1] + 1
            sub_counts.reset_index(inplace=True)
            sub_counts['i'] = sub_indices
            sub_counts.set_index('i', inplace=True)
            sub_tables.append(sub_counts)

        sub_tables.append(tax_table[~tax_table[tax_ranks[-1]].isnull()])

        join_table = pd.concat(sub_tables)
        for tax_rank in tax_ranks:
            if tax_rank not in join_table.columns:
                join_table[tax_rank] = np.nan

        join_table = join_table[tax_ranks + samples]
        join_table.sort_values(tax_ranks, ascending=True, na_position='first', inplace=True)

        if 'report' in config and 'tsv' in config['report'] and 'remove_marginal_taxes' in config['report']['tsv'] and config['report']['tsv']['remove_marginal_taxes']:
            # Remove marginal taxes, e.g Bacteria from 28S samples
            tax_sums = list(join_table.sum(axis=1))
            root_counts = join_table.iloc[np.argmax(tax_sums)]
            domain = tax_ranks[0]
            join_table = join_table[join_table[domain] == root_counts[domain]]
        else:
            root_counts = tax_table.sum()

        join_table.to_excel(output.subtax_xlsx, index=False)
        join_table.to_csv(output.subtax_tsv, sep='\t', index=False)

        # Normalise join table
        normed = join_table[tax_ranks]
        for sample in samples:
            root_count = root_counts[sample]
            normed[sample] = join_table[sample].apply(lambda x: x / root_count)

        normed.to_excel(output.normed_xlsx, index=False)
        normed.to_csv(output.normed_tsv, sep='\t', index=False)

rule summarize_taxonomic_level:
    input:
        subtax_tsv = '{analysis_dir}/{gene}/report/tsv/subtaxes.tsv'
    output:
        tax_level_abs = '{analysis_dir}/{gene}/report/tsv/{tax_level, %s}.abs.tsv' % ('|'.join(tax_ranks[:-1])),
        tax_level_rel = '{analysis_dir}/{gene}/report/tsv/{tax_level, %s}.rel.tsv' % ('|'.join(tax_ranks[:-1]))
    run:
        global tax_ranks

        join_table = pd.read_csv(input.subtax_tsv, sep='\t')

        target_level = wildcards.tax_level
        target_level_loc = tax_ranks.index(target_level)
        next_level = tax_ranks[target_level_loc + 1]

        if target_level not in join_table.columns:
            with open(output.tax_level_tsv, 'w') as out:
                out.write('')

        tax_counts = join_table[~join_table[target_level].isnull()]
        if next_level in join_table.columns:
            tax_counts = tax_counts[tax_counts[next_level].isnull()]

        samples = [tc for tc in tax_counts.columns if tc not in tax_ranks]
        used_ranks = tax_ranks[:target_level_loc+1]
        tax_counts = tax_counts[used_ranks + samples]

        tax_counts.to_csv(output.tax_level_abs, sep='\t', index=None)

        # Relative counts
        tax_ratios = tax_counts[used_ranks]
        for sid, sample_counts in tax_counts[samples].iteritems():
            tax_ratios[sid] = sample_counts / sample_counts.sum()

        tax_ratios.to_csv(output.tax_level_rel, sep='\t', index=None)


rule summarize_barplot:
    input:
        tax_level = '{analysis_dir}/{gene}/report/tsv/{tax_level}.{count_type}.tsv'
    output:
        barplot = '{analysis_dir}/{gene}/report/figures/{tax_level, %s}.{count_type, rel|abs}.{format, %s}' % ('|'.join(tax_ranks[:-1]),
                                                                                                               '|'.join(SUPPORTED_IMAGE_FORMATS))
    run:
        SUM_COL = 'rowsum'
        MAX_TAXONS = 9

        global tax_ranks

        # Load taxonomic counts from desired tax_level, e.g. phylum
        counts = pd.read_csv(input.tax_level, sep='\t')
        sids = [col for col in counts.columns if col not in tax_ranks]
        used_ranks = [col for col in counts.columns if col in tax_ranks]

        # Select only limited number of the most abundant taxons
        counts[SUM_COL] = counts.sum(axis=1)
        counts.sort_values(by=SUM_COL, inplace=True)
        tops, rest = counts.iloc[-MAX_TAXONS:], counts.iloc[:-MAX_TAXONS]

        # Aggregate the rest of taxons into the one "Other" taxon
        rest_sum = rest[sids + [SUM_COL]].sum()
        rest_sum.set_value(wildcards.tax_level, 'Other')
        plot_counts = tops.iloc[::-1].append(rest_sum, ignore_index=True)[[wildcards.tax_level] + sids].set_index(wildcards.tax_level)

        # Plot the most abundant and "Other" taxons
        sns.set(context='paper', font_scale=2, palette=sns.color_palette("hls", MAX_TAXONS+1))
        sns.set_style('whitegrid')
        plot_counts.T.plot(kind='bar', stacked=True, legend=False, figsize=(18, 12))
        plt.legend(loc='upper center', bbox_to_anchor=(0.5,1.14), ncol=5)
        plt.tight_layout(pad=4)
        plt.grid()

        # Store plot
        plt.savefig(output.barplot)