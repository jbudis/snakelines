import oyaml
import shutil

# Filter samples according to the user configuration
sample_pattern = config.get('sample_pattern', '.*')
pipeline = glob_wildcards('reads/original/{sample, %s}_R1.fastq.gz' % sample_pattern)
assert len(pipeline.sample) > 0, 'No samples in reads/original/ match configured pattern {}'.format(sample_pattern)

# Helper methods

def extract_from_config(items, default_value):
    '''
    Load items from the configuration file based on series of keys. If some key is not found in hierarchy,
    return default value specified as the parameter.

    :param items: list str: series of keys to hierarchically find item in the configuration file
    :param default_value: value to return if the series of keys are not present in the configuration
    '''
    subconfig = config
    for item in items:
        if item not in subconfig:
            return default_value
        subconfig = subconfig[item]
    return subconfig


def configured_temp(read_file):
    '''
    Choose if Fastq file should be marker by snakemake temporary flag temp() based on configuration

    :param read_file: output read file of a read preprocess rule
    '''
    items = read_file.split('/')
    assert items[0] == 'reads' and len(items) == 3, \
           'Method can be used only for read files in reads/{preprocess}/ directory, provided {}'.format(read_file)

    read_type = items[1]
    temporary = extract_from_config(['reads', 'preprocess', read_type, 'temporary'], False)
    return temp(read_file) if temporary else read_file


def copy_input_files_with_consistent_output_names(input, output):
    '''
    Compare names of the inputs and outputs of the rule. All items with the same name in inputs and outputs are copied,
    therefore generate output files.

    :param input: input files of the rule
    :param output: output files of the rule
    '''

    # Iterate through all defined outputs in the rule
    for item_name in output.__dict__:

        # Skip internal snakemake attributes
        if item_name.startswith('_'):
            continue

        # Skip output items do not have matching partner in input
        if not hasattr(input, item_name):
            continue

        # Check if items with the same name have also same data type, both should be list or str
        input_item, output_item = getattr(input, item_name), getattr(output, item_name)
        assert type(input_item) == type(output_item), 'Output and input items with name {} \
                    for the rule have different data types {} and {}'.format( \
                    item_name, type(input_item), type(output_item))

        # Check if items with the same name have also same length
        assert len(input_item) == len(output_item), 'Output and input items with name {} \
                for the rule have different lengths {} and {}'.format(item_name, len(input_item), len(output_item))

        # Single file items are directly copied
        if type(input_item) == str:
            shutil.copy(input_item, output_item)

        # List items are copied item by item
        for in_item, out_item in zip(input_item, output_item):
            shutil.copy(in_item, out_item)


# Impute read types into the preprocess steps
ORIGINAL_READS = 'original'

for config_file in workflow.configfiles:

    # Load configuration with dictionary that keeps order of the preprocess steps
    file_config = oyaml.load(open(config_file))

    # Find configuration file with reads->preprocess attributes
    if 'preprocess' not in file_config.get('reads', {}):
        continue

    # Add new read_type attribute to the main config, so rules for preprocess steps may deduce input read files
    previous_type = ORIGINAL_READS
    for read_type in file_config['reads']['preprocess'].keys():
        config['reads']['preprocess'][read_type]['input_read_type'] = previous_type
        previous_type = read_type


# Automatically import snake files that match the configuration structure

def import_files_in_config(subconfig, item_path):
    '''
    Recursively traverse configuration file and identify possible snake imports annotated by "method:" node

    :param subconfig: part of configuration file to traverse
    :param item_path: already traversed path in the configuration file
    '''

    # Directories and lists are searched recursively
    if type(subconfig) == dict:

        # Search all elements of the current item
        for next_item_name in subconfig:
            if next_item_name == 'method':
                yield '{}/{}.snake'.format(item_path, subconfig[next_item_name]), subconfig
                continue

            next_item_path = '{}/{}'.format(item_path, next_item_name)

            yield from import_files_in_config(subconfig[next_item_name], next_item_path)

    # Items at the end of the configuration tree are checked as well
    if type(subconfig) == str:
        yield from import_files_in_config(None, '{}/{}'.format(item_path, subconfig))

for import_file, tool_config in import_files_in_config(config, config['snake_dir']):
    assert os.path.isfile(import_file), 'Configured snake file {} does not exists'.format(import_file)
    include: import_file
