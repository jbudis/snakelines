import oyaml
import shutil

# Filter samples according to the user configuration
sample_pattern = config.get('sample_pattern', '.*')
pipeline = glob_wildcards('reads/original/{sample, %s}_R1.fastq.gz' % sample_pattern)
assert len(pipeline.sample) > 0, 'No samples in reads/original/ match configured pattern {}'.format(sample_pattern)

# Helper methods
def extract_from_config(items, default_value):
    '''
    Load items from the configuration file based on series of keys. If some key is not found in hierarchy,
    return default value specified as the parameter.

    :param items: list str: series of keys to hierarchically find item in the configuration file
    :param default_value: value to return if the series of keys are not present in the configuration
    '''
    subconfig = config
    for item in items:
        if item not in subconfig:
            return default_value
        subconfig = subconfig[item]
    return subconfig

def copy_input_files_with_consistent_output_names(input, output):
    '''
    Compare names of the inputs and outputs of the rule. All items with the same name in inputs and outputs are copied,
    therefore generate output files.

    :param input: input files of the rule
    :param output: output files of the rule
    '''

    print(getattr(output, 'reports'))
    # Iterate through all defined outputs in the rule
    for item_name in output.__dict__:

        # If output items do not have matching partner in input, print warning message
        if not hasattr(input, item_name):
            print('Output of the rule with the name {} has no input attribute with the same name.'.format(item_name))
            continue

        # Check if items with the same name have also same data type, both should be list or str
        input_item, output_item = getattr(input, item_name), getattr(output, item_name)
        if type(input_item) != type(output_item):
            print('Output and input items with name {} for the rule have different data types {} and {}'.format(
                    item_name, type(input_item), type(output_item)))
            continue

        # Check if items with the same name have also same length
        if len(input_item) != len(output_item):
            print('Output and input items with name {} for the rule have different lengths {} and {}'.format(
                    item_name, len(input_item), len(output_item)))
            continue

        # Single file items are directly copied
        if type(input_item) == str:
            shutil.copy(input_item, output_item)

        # List items are copied item by item
        for in_item, out_item in zip(input_item, output_item):
            shutil.copy(in_item, out_item)


# Impute read types into the preprocess steps
ORIGINAL_READS = 'original'

for config_file in workflow.configfiles:

    # Load configuration with dictionary that keeps order of the preprocess steps
    file_config = oyaml.load(open(config_file))

    # Find configuration file with reads->preprocess attributes
    if 'preprocess' not in file_config.get('reads', {}):
        continue

    # Add new read_type attribute to the main config, so rules for preprocess steps may deduce input read files
    previous_type = ORIGINAL_READS
    for read_type in file_config['reads']['preprocess'].keys():
        config['reads']['preprocess'][read_type]['input_read_type'] = previous_type
        previous_type = read_type


# Automatically import snake files that match the configuration structure

def import_files_in_config(subconfig, item_path):

    # Check if path in the configuration match some snake file in src/ directory
    import_file = '{}.snake'.format(item_path)
    if os.path.isfile(import_file):
        yield import_file
        return

    # Directories and lists are searched recursively
    if type(subconfig) == dict:

        # Search all elements of the current item
        for next_item_name in subconfig:
            next_item_path = item_path

            # Do not include "method" attribute into the paths
            if next_item_name != 'method':
                next_item_path = '{}/{}'.format(next_item_path, next_item_name)

            yield from import_files_in_config(subconfig[next_item_name], next_item_path)

    # Items at the end of the configuration tree are checked as well
    if type(subconfig) == str:
        yield from import_files_in_config(None, '{}/{}'.format(item_path, subconfig))

for import_file in import_files_in_config(config, config['snake_dir']):
    print('Automatically imported snake file {}'.format(import_file))
    include: import_file
