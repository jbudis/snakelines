include: config['snake_dir'] + '/preprocess/conversion/unzip.snake'

from glob import glob
import pandas as pd

read_type  = config['metaxa2']['read_type']

def r_file(wildcards, orientation):
    read_dir = read_type
    if '{gene}' in read_dir:
        read_dir = read_dir.format(gene=wildcards.reference)

    return 'reads/%s/%s_R%s.fastq' % (read_dir, wildcards.sample, orientation)

def r1_file(wildcards):
    return r_file(wildcards, '1')

def r2_file(wildcards):
    return r_file(wildcards, '2')

rule metaxa2_classification:
    input:
        r1 = r1_file,
        r2 = r2_file,
        blast = 'reference/{reference}/metaxa2_index/blast.nhr',
        cutoffs = 'reference/{reference}/metaxa2_index/blast.cutoffs.txt',
        hmm = 'reference/{reference}/metaxa2_index/HMMs/E.hmm'
    output:
        taxonomy = 'metaxa2/{reference}/classification/{sample}/{sample}.taxonomy.txt'
    params:
        outpref = 'metaxa2/{reference}/classification/{sample}/{sample}',
        confidence = int(100*float(config['metaxa2'].get('confidence', 0.8))),
        hmm_dir = 'reference/{reference}/metaxa2_index/HMMs',
        blast_prefix = 'reference/{reference}/metaxa2_index/blast'
    log:
        'metaxa2/{reference}/classification/{sample}/log/metaxa2.log'
    threads:
        int(config['threads'])
    shell:
        '''
        metaxa2 \
            -1 {input.r1} \
            -2 {input.r2} \
            -o {params.outpref} \
            -g {wildcards.reference} \
            -R {params.confidence} \
            -p {params.hmm_dir} \
            -d {params.blast_prefix} \
            -T {input.cutoffs} \
            --plus T \
            --cpu {threads} \
        > {log}
        '''

rule metaxa2_create_index:
    input:
        fasta = 'reference/{reference}/{reference}.fa',
        tax = 'reference/{reference}/{reference}.tax'
    output:
        blast = protected('reference/{reference}/metaxa2_index/blast.nhr'),
        cutoffs = protected('reference/{reference}/metaxa2_index/blast.cutoffs.txt'),
        hmm = protected('reference/{reference}/metaxa2_index/HMMs/E.hmm'),
    params:
        index_dir = 'reference/{reference}/metaxa2_index'
    threads:
        int(config['threads'])
    log:
        out = 'reference/{reference}/metaxa2_index/log/db.log',
        err = 'reference/{reference}/metaxa2_index/log/db.err'
    shell:
        '''
        metaxa2_dbb \
            -i {input.fasta} \
            -o {params.index_dir} \
            -g {wildcards.reference} \
            -t {input.tax} \
            --auto_rep T \
            --cpu {threads} \
            --plus T \
         > {log.out} \
        2> {log.err}
        '''


rule metaxa2_summarize_classification:
    input:
        taxonomy = 'metaxa2/{gene}/classification/{sample}/{sample}.taxonomy.txt',
        nomatch_template = srcdir('metaxa2/nomatch.txt'),
        nomatch_tax_template = srcdir('metaxa2/nomatch.level_7.txt')
    output:
        summary = 'metaxa2/{gene}/classification/{sample}/{sample}.level_7.txt',
    params:
        outpref = 'metaxa2/{gene}/classification/{sample}/{sample}',
        nomatch_taxonomy = 'metaxa2/{gene}/classification/{sample}/{sample}.taxonomy.nomatch.txt'
    log:
        'metaxa2/{gene}/classification/{sample}/log/metaxa2_ttt.log'
    shell:
        '''
        TAXONOMY={input.taxonomy}
        if [ ! -s {input.taxonomy} ];
        then
            cp {input.nomatch_template} {params.nomatch_taxonomy}
            TAXONOMY={params.nomatch_taxonomy}
            echo $TAXONOMY
        fi
        metaxa2_ttt \
                -i $TAXONOMY \
                -o {params.outpref} \
        > {log}

        if [ ! -f {output.summary} ];
        then
            cp {input.nomatch_tax_template} {output.summary}
        fi
        '''



rule metaxa2_prepare_for_krona:
    input:
        classification = 'metaxa2/{gene}/classification/{sample}/{sample}.level_7.txt'
    output:
        krona = 'metaxa2/{gene}/report/krona/individual/{sample}.krn'
    run:

        def most_specialized_classification(wildcards):

            def get_class_level(class_file):
                level = class_file.split('_')[-1].split('.')[0]
                return int(level)

            class_files = glob('metaxa2/{gene}/classification/{sample}/{sample}.level_*.txt'.format(
                               gene=wildcards.gene, sample=wildcards.sample))

            return sorted(class_files, key=get_class_level)[-1]

        invalid_tags = ['unclassified', 'unknown', 'uncultured']

        def is_informative(taxon):
            for tag in invalid_tags:
                if tag in taxon.lower():
                    return False
            return True

        def to_krona_format(tax):
            items = tax.strip(';').split(';')
            for i, item in enumerate(items):
                if not is_informative(item):
                    items = items[:i]
                    break
            return '\t'.join(items)

        counts = pd.read_csv(most_specialized_classification(wildcards), sep='\t', header=None)
        counts.columns = ['tax', 'reads']
        counts['tax_refined'] = counts['tax'].apply(to_krona_format)

        with open(output.krona, 'w') as out:
            for _, row in counts.iterrows():
                out.write('{row.reads}\t{row.tax_refined}\n'.format(row=row))


rule metaxa2_krona_report:
    input:
        'metaxa2/{gene}/report/krona/individual/{sample}.krn'
    output:
        'metaxa2/{gene}/report/krona/individual/{sample}.html'
    log:
        'metaxa2/{gene}/report/krona/individual/log/{sample}.krona'
    shell:
        '''
        ktImportText \
            -o {output} \
            {input} \
        > {log}
        '''
