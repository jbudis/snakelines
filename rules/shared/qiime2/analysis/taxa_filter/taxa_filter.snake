include: config['snakelines_dir'] + '/rules/shared/qiime2/preprocess/report/export/export.snake'


def process_filter_input(config_input, param):
    if config_input is False or len(config_input)<1:
        return ''
    else:
        return param+' '+config_input


rule qiime2__taxa_filter_table:
    """
    This method filters features from a table based on their taxonomic annotations. Features can be retained in the resulting table by specifying one or more include search terms, and can be filtered out of the resulting table by specifying one or more exclude search terms.
    If both include and exclude are provided, the inclusion critera will be applied before the exclusion critera.
    When no include or exclude criteria are provided, the input is copied to output.
    Any samples that have a total frequency of zero after filtering will be removed from the resulting table.

    Calls 'qiime taxa filter-table'

    :input feature_table: feature table produced by dada2
    :input taxonomy: taxonomic annotations for features in the provided feature table
    :output filtered_table: resulting feature table after filtering
    :params include: criteria that must hold to keep ASV
    :params exclude: criteria that cannot hold to keep ASV
    """
    input:
        feature_table = 'reads/preprocess/denoise/%s/{reference}_table.qza' % pipeline.qiime2_type,
        taxonomy  = 'reads/taxonomy/{reference}_tax.qza'
    output:
        filtered_table = 'reads/preprocess/denoise/%s/{reference}_table.qza' % pipeline.qiime2_post_taxa
    log:
        out = 'reads/preprocess/denoise/taxa_filter/log/{reference}_filter_table.log',
        err = 'reads/preprocess/denoise/taxa_filter/log/{reference}_filter_table.err'
    conda:
        config['snakelines_dir'] + '/environments/qiime2.yaml'
    threads:
        int(config['threads'])
    params:
        include = process_filter_input(method_config.get('include', False), '--p-include'),
        exclude = process_filter_input(method_config.get('exclude', False), '--p-exclude')
    shell:
        '''
        if [ "{params.include}" == "" ] && [ "{params.exclude}" == "" ];
        then
            echo "Skipping taxonomy filtering as no filtering conditions are set" \
            > {log.out}
            cp {input.feature_table} {output.filtered_table}
        else
            qiime taxa filter-table \
                --i-table {input.feature_table} \
                --i-taxonomy {input.taxonomy} \
                {params.include} \
                {params.exclude} \
                --o-filtered-table {output.filtered_table} \
                1> {log.out} \
                2> {log.err}
        fi;
        '''

rule qiime2__taxa_filter_seqs:
    """
    This method filters sequences based on their taxonomic annotations. Features can be retained in the resulting table by specifying one or more include search terms, and can be filtered out of the resulting table by specifying one or more exclude search terms.
    If both include and exclude are provided, the inclusion critera will be applied before the exclusion critera.
    When no include or exclude criteria are provided, the input is copied to output.
    Any samples that have a total frequency of zero after filtering will be removed from the resulting table.

    Calls 'qiime taxa filter-seqs'

    :input rep_seqs: representative feature sequences as produced by dada2
    :input taxonomy: taxonomic annotations for features in the provided feature sequences
    :output filtered_seqs: resulting feature sequences after filtering
    :params include: criteria that must hold to keep ASV
    :params exclude: criteria that cannot hold to keep ASV
    """
    input:
        rep_seqs = 'reads/preprocess/denoise/%s/{reference}_rep-seqs.qza' % pipeline.qiime2_type,
        taxonomy  = 'reads/taxonomy/{reference}_tax.qza'
    output:
        filtered_seqs = 'reads/preprocess/denoise/taxa_filter/{reference}_rep-seqs.qza'
    log:
        out = 'reads/preprocess/denoise/log/{reference}_filter_seqs.log',
        err = 'reads/preprocess/denoise/log/{reference}_filter_seqs.err'
    conda:
        config['snakelines_dir'] + '/environments/qiime2.yaml'
    threads:
        int(config['threads'])
    params:
        include = process_filter_input(method_config.get('include', False), '--p-include'),
        exclude = process_filter_input(method_config.get('exclude', False), '--p-exclude')
    shell:
        '''
        if [ "{params.include}" == "" ] && [ "{params.exclude}" == "" ];
        then
            echo "Skipping taxonomy filtering as no filtering conditions are set" \
            > {log.out}
            cp {input.rep_seqs} {output.filtered_seqs}
        else
            qiime taxa filter-seqs \
                --i-sequences {input.rep_seqs} \
                --i-taxonomy {input.taxonomy} \
                {params.include} \
                {params.exclude} \
                --o-filtered-sequences {output.filtered_seqs} \
                1> {log.out} \
                2> {log.err}
        fi;
        '''

rule qiime2__taxonomy_barplot_filtered:
    """
    :input filtered_table: feature table filtered using taxonomy
    :input taxonomy: produced taxonomy as qza
    :input metadata: samples metadata filepath in TSV format (tab-separated value), e.g. description/silva16S-sample-metadata.tsv
    """
    input:
        taxonomy = 'reads/taxonomy/{reference}_tax.qza',
        filtered_table = 'reads/preprocess/denoise/taxa_filter/{reference}_table.qza',
        metadata = 'description/sample-metadata.tsv',
    output:
        barplot = 'reads/taxonomy/{reference}_barplot_filtered.qzv'
    log:
        out = 'reads/taxonomy/log/{reference}_barplot_filtered.out',
        err = 'reads/taxonomy/log/{reference}_barplot_filtered.err'
    conda:
        config['snakelines_dir'] + '/environments/qiime2.yaml'
    shell:
        '''
        qiime taxa barplot \
            --i-table {input.filtered_table} \
            --i-taxonomy {input.taxonomy} \
            --m-metadata-file {input.metadata} \
            --o-visualization {output.barplot} \
            1> {log.out} \
            2> {log.err}
        '''
