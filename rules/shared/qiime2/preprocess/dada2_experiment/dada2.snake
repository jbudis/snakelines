def parse_parameter_from_input(parameter, label, default_value):
    if label in config['qiime2_experiment']['dada2'] and parameter in config['qiime2_experiment']['dada2'][label]:
        return config['qiime2_experiment']['dada2'][label][parameter]
    method_input = config['qiime2']['preprocess']['dada2_experiment']
    return method_input.get(parameter, default_value)

def parse_trunc_len_f(wildcards):
    return parse_parameter_from_input('trunc_len_f', wildcards.label, 0)

def parse_trunc_len_r(wildcards):
    return parse_parameter_from_input('trunc_len_r', wildcards.label, 0)

def parse_trim_left_f(wildcards):
    return parse_parameter_from_input('trim_left_f', wildcards.label, 0)

def parse_trim_left_r(wildcards):
    return parse_parameter_from_input('trim_left_r', wildcards.label, 0)

def parse_max_ee_f(wildcards):
    return parse_parameter_from_input('max_ee_f', wildcards.label, 2.0)

def parse_max_ee_r(wildcards):
    return parse_parameter_from_input('max_ee_r', wildcards.label, 2.0)

def parse_trunc_q(wildcards):
    return parse_parameter_from_input('trunc_start_qual', wildcards.label, 2)

def parse_min_overlap(wildcards):
    return parse_parameter_from_input('min_overlap', wildcards.label, 12)

def parse_denoise_pooling(wildcards):
    return parse_parameter_from_input('denoise_pooling', wildcards.label, 'independent')

def parse_chimera_method(wildcards):
    return parse_parameter_from_input('chimera_method', wildcards.label, 'consensus')

def parse_chimera_parent_abundance(wildcards):
    return parse_parameter_from_input('chimera_parent_abundance', wildcards.label, 1.0)

def parse_num_reads_train(wildcards):
    return parse_parameter_from_input('num_reads_train', wildcards.label, 1000000)


rule qiime2__dada2_denoise_experiment:
    """
    Denoises sequences, dereplicates them, and filters chimeras.
    Calls 'qiime dada2 denoise-paired' or 'qiime dada2 denoise-single'
    :input demux_sequences: Imported demultiplexed sequences with cut adapters
    :output table: resulting feature table of qiime2 dada2 call
    :output rep_seqs: resulting feature sequences, feature in the feature table is represented by exactly one sequence, and in case of paired-end, these sequences will be the joined paired-end sequences
    :output stats: resulting stats of qiime2 dada2 call
    :params sequen: str, type of sequencing, either single-end or paired-end, derived from main config
    :params minlen: int, required min length of sequences to be kept after cutting adapters
    :params maxerr: float 0-1, maximum allowed error rate of sequence to be kept
    """
    input:
        demux_sequences = 'qiime2/preprocess/demultiplex/{reference}.qza'
    output:
        table = 'qiime2/dada2_experiment/preprocess/{label}/{reference}_table.qza',
        rep_seqs = 'qiime2/dada2_experiment/preprocess/{label}/{reference}_rep-seqs.qza',
        stats = 'qiime2/dada2_experiment/preprocess/{label}/{reference}_denoising-stats.qza'
    log:
        out = 'qiime2/dada2_experiment/preprocess/{label}/log/dada2_{reference}.log',
        err = 'qiime2/dada2_experiment/preprocess/{label}/log/dada2_{reference}.err'
    threads:
        int(config['threads'])
    params:
        sequen = config['sequencing'].split("_end")[0],
        trunc_len_f = parse_trunc_len_f,
        trunc_len_r = parse_trunc_len_r,
        trim_left_f = parse_trim_left_f,
        trim_left_r = parse_trim_left_r,
        max_ee_f = parse_max_ee_f,
        max_ee_r = parse_max_ee_r,
        trunc_q = parse_trunc_q,
        min_overlap = parse_min_overlap,
        denoise_pooling = parse_denoise_pooling,
        chimera_method = parse_chimera_method,
        chimera_parent_abundance = parse_chimera_parent_abundance,
        num_reads_train = parse_num_reads_train,
    conda:
        config['snakelines_dir'] + '/environments/qiime2.yaml'
    shell:
        '''
        qiime dada2 denoise-{params.sequen} \
            --i-demultiplexed-seqs {input.demux_sequences} \
            --o-table {output.table}  \
            --o-representative-sequences {output.rep_seqs} \
            --o-denoising-stats {output.stats} \
            --p-n-threads {threads} \
            --p-trunc-len-f {params.trunc_len_f} \
            --p-trunc-len-r {params.trunc_len_r} \
            --p-trim-left-f {params.trim_left_f} \
            --p-trim-left-r {params.trim_left_r} \
            --p-max-ee-f {params.max_ee_f} \
            --p-max-ee-r {params.max_ee_r} \
            --p-trunc-q {params.trunc_q} \
            --p-min-overlap {params.min_overlap} \
            --p-pooling-method {params.denoise_pooling} \
            --p-chimera-method {params.chimera_method} \
            --p-min-fold-parent-over-abundance {params.chimera_parent_abundance} \
            --p-n-reads-learn {params.num_reads_train} \
            1> {log.out} \
            2> {log.err}
        '''

rule qiime2__dada2_tabulate_stats:
    """
    Generates a tabular view of resulting dada2 stats.
    Calls 'qiime metadata tabulate'
    :input dada2stats: dada2 stats artifact
    :output visualization: visualization of dada2 stats artifact
    """
    input:
        dada2_stats = 'qiime2/dada2_experiment/preprocess/{label}/{reference}_denoising-stats.qza'
    output:
        vis_denoise_stats = 'qiime2/dada2_experiment/preprocess/{label}/{reference}_denoising-stats.qzv'
    conda:
        config['snakelines_dir'] + '/environments/qiime2.yaml'
    shell:
        '''
        qiime metadata tabulate \
            --m-input-file {input.dada2_stats} \
            --o-visualization {output.vis_denoise_stats}
        '''
