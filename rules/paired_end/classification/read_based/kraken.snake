#checkpoint kraken__download_taxonomy:
#    output:
#        db_path = directory(method_config.get('db_path'))
#    conda:
#        config['snakelines_dir'] + '/enviroments/kraken2.yaml'
#    params:
#        database = method_config.get('database')
#    shell:
#        '''
#        kraken2-build \
#            --download-taxonomy\
#            --db "{output.db_path}"
#        '''


def individual_samples(wildcards):
    print(wildcards)
    return expand('reads/%s/{sample}_{parity}.fastq.gz' % pipeline.preprocessed_read_type,
                    sample=wildcards.sample,
                    parity=['R1', 'R2'])


rule kraken__classify_reads:
    """
    @TODO
    """
    input:
        samples = individual_samples(wildcards),
        database = directory('reference/{reference}'),
    output:
        'classification/{reference}/report/kraken/out.report'
    log:
        out = 'classification/{reference}/report/kraken/log/kraken__classify_reads.log',
        err = 'classification/{reference}/report/kraken/log/kraken__classify_reads.err',
    conda:
       config['snakelines_dir'] + '/environments/kraken2.yaml'
    threads:
        int(config['threads'])
    resources:
        mem_mb=500000 # DB loading needed
    shell:
        '''
        kraken2 \
            --gzip-compressed \
            --db {input.database} \
            --threads {threads} \
            --report {output} \
            --paired \
            {input.samples} \
            2> {log.err} \
            1> {log.out}
        '''

rule krona__convert_report:
    input:
        'classification/{reference}/report/kraken/out.report'
    output:
        'classification/{reference}/report/krona/all_samples.krn'
    log:
        out = 'classification/{reference}/report/krona/log/krona__convert_report.log',
        err = 'classification/{reference}/report/krona/log/krona__convert_report.err',
    conda:
       config['snakelines_dir'] + '/environments/krakentools.yaml'
    shell:
        '''
        kreport2krona.py \
            --report {input} \
            --output {output} \
            2> {log.err} \
            1> {log.out}
        '''

